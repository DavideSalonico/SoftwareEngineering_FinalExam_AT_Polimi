TO DO LIST:

1) rendere Resizable tutti i componenti della view senza che si sballino le griglie, scegliere una formato predefinito per la riduzione
    di finestra sotto-multiplo della finestra a schermo intero

2) Leggere correttamente il file CSS relativo alla GUI con il suo percorso (fare in modo che sia compatibile anche su MAC)

3) Generare in maniera dinamica il numero delle Shelf relative agli altri player e decidere come disporle a schermo

4) Far vedere tutti i nickname dei giocatori e i loro punteggi posizionandoli affiancati alle rispettive Shelf

5) Capire come eseguire una corretta astrazione della GUI suddividendola correttamente tra file FXML (sceneBuilder), CSS,
    Controller e Classe per lanciare la GUI (al momento tutto concentrata in GUIApplication)

6) Gestire gli eventi relativi al click da parte di un utente

7) Gestire i turni di gioco e le relative azioni che un utente può compiere ( probabiblmente con un enum che indica lo stato del player)

8) Effettuare i controlli su azioni possibili e non possibili da parte di un utente (es. non posso pescare se ho gia 7 carte in mano)

9) Capire come ricevere dinamicamente le istanze di GameView e fare in modo che si aggiorni tutta la view di conseguenza (scrivere il
    metodo risvegliato dal propertyChange)

10) Capire quando e come un utente che esegue un azione può devo comunicare al serverRMI che ha finito il suo turno e compiuto le sue azioni

11) Gestire il fatto che un utente si scolleghi e poi eventualmente riprenda inizializzando la view dall'utlimo stato di gioco (sfruttando la persistenza)

12) Capire come gestire la chat ( da posizionare sul lato dx della view), come strutturla e farla funzionare correttamente

13) Gestire TUTTI gli eventi correttamente con le INVOKELATER in modo che la GUI rimanga responsive e non si blocchi

14) Pingare con una certa frequenza tutti i giocatori per verificare che siano ancora connessi al gioco (se non rispondono entro un certo
    tempo li si disconnette)

15) Gestire la transizione da Lobby alla view di gioco

16) Gestire la terminazione di una partita e la conseguente visualizzazione della classifica

17) Implementare tutto il controller della LobbyView

Appunti sulla GUI:

-Non conviene piu usare gli Observer perchè sono poco scalabili, ho sempre bisogno di una lista di Observer e devo gestire il comportamento tra di loro;
 utilizzo quindi Publish-Subscriber che gestiscono la loro interazione in maniera modulare

-Cosa fondamentale, capire bene come separarle dalla logica, una GUI deve essere abbastanza responsiva ed estendibile, altrimenti un generico
 user penserà che si sia bloccato il funzionamento, cosa che con CLI non accade

-Libreria da usare "Swing", che dovrebbe comprendere tutte le funzionalità pure della "AWT"

-Tutti i componenti della libreria Swing inziano con J (tipo JButton etc)

-Swing astrae già di suo i componenti leggeri, a noi basta eridetarli e ovverridarli a piacere

-All'interno della GUI ci sarà un ulteriore MVC, modello definisce gli attributi modificabili di un componente della view, la view
 rifletterà il comportamento che viene invece definito dentro il controller (che definisci tramite i listener, il comportamento
 da scatenare)

-C'è un importante gerarchia da rispettare all'interno dell'interfaccia grafica

-Componente tipici elementi generici (bottoni, checkbox etc)

-Contanainer contiene componenti, permette di aggiungerne e mostrarli a piacimento, serve pure banalmente per permettere un click su
 zona piu ampia di interfaccia, una Top-level può essere rappresentata indipendemente, le altre no. (JApplet deprecato)
 Nel container ci sono vari layer, quello che ci interessa modificare è CONTENT PANE (ci inserisco i componenti), infine c'è un GLASS PANE
 che permette di catturare tutti gli eventi, è quello che capta l'eventuale click e scatena i click nei relativi component

-Frame (tipo specifico di Window), definisce la struttura dell'interfaccia, inizia i suoi layer dalla rootPane (da non toccare),
 per poi modificare i layer sottostanti.
 Ha metodi semplici come setSize(x,y) della interf, o setLocation(x,y),
 Mettere sempre setVisible(true), ovviamente a discrezione del componente, del frame etc
 Quando chiudo la finestra principale sto chiudendo il gioco definitavemento, setDefaultCloseOperation(JFRAME.exit),
 Guarda la documentazione su cose tipo centrare la finestra senza sbattersi sulle size etc,
 Se faccio direttamente una add sul frame la mette direttamente nel contentPane,
 frame.pack() lo compatta in dimensioni ottimali, posso pure fissare la dimensione di una Prefered-Window-Size,

-JDialog sono delle window ben strutturate per mostrare dei messaggi a schermo, stile non troppo modificabile, posso modificarne
 il conetenuto aggiungendo pure buttoni di selezione etc ( tipo "Sei sicuro di voler continuare "  SI  NO  CHIUDI),
 setta il LOOKANDFEEL che è più carino

-JPanel serve per organizzare a livello visivo certi componenti, anche a livello Gerarchico

-PER CHAT: FRAME -> JSCrollPane -> Componente di Testo per chat (altrimenti non è scorribile)

-JLayeredPane serve per definire dei livelli dentro al frame (componenti che si sovrappongono per priorità)

-Svariati componenti sulle slide

-JText Field ( hanno dei figli specifici per il login, vedi slide )

-metodo setTollTipText(testo) da suggerimento di testo sulle icone


-Layout specifica la vista in base ai Container (utilizza un Strategy), SE CAMBIO LAYOUT BISOGNA PRIMA INVALIDARE I COMPONENTI E
 POI RIACCENDERE QUELLI DI INTERESSE (solo alcuni lo fanno in automatico)

    -FlowLayout, tutti componenti uno di fianco all'altro, se sono troppi non vengono mostrati quelli extra, serve finestra piu grossa
    -BorderLayout, diviso in 5 zone (N,S,W,E,Center) e si allargano in funzione dell'espansione in una direzione
    -GridLayout o GridBadLayout è una grafica tutta a griglia e lavoro su determinate celle dell'interfaccia

-I bordi devono essere settati con i .setBorder("metodi da doc")


-EventListener è un interfaccia generale che ascolta gli eventi, EventHandler li gestisce
-ActionEvent(interfaccia) è l'evento che passo, actionEvent.getSource() mi ritorna il componente chi lo ha generato (deprecato perchè mi serve un Switch case terribile)
-   .addActionListener(oggetto che cattura l'evento)   scatena la actionPerformed(ActionEvent e) in automatico, in piu l'attributo gli viene passato automaticamente senza bisogno che lo setti manualmente
        capisco in automatico chi mi scatena l'evento cossichè non devo fare nessuno switch.... in ogni caso per fini di debug si puo sempre prendere il
        .getSource() dall'ActionEvent per capire chi ha scatenato l'evento.

-Swing Thread per fare cose in parallelo e non sequenziale
    InitialThread istanzia la GUI ed esegue codice base
    EventDispatchThread (EDT)ascolta gli eventi e li distribuisce a chi di interesse, possiede coda di eventi e smistati a dovere

    EDT ha una coda di azioni da eseguire a livello di software, se io ho interagisco col mouse per fare delle modifiche,
    HO BISOGNO DI CHIAMARE initialThread.INVOKELATER() perchè è initialThread che riceve info da fonti esterne,
    per inserire anche le modifiche di agenti esterni nella coda delle azioni da eseguire dall' EDT

-Posso inserire file XML per configurazioni base

-Scene Builder su Java FX è grafica, conviene prima fare in Java Swing e poi andare in Java FX perchè è molto difficile git debuggare poi



- FAI controller della Lobby e del Game
- Metti ad FXML qualsiasi metodo associato ai componenti della View
- Ogni metodo esterno di aggiornamento di View devi mettere PLATFORM.RUNLATER() perchè è un thread esterno che deve aggiornare la GUI
    usa lambda expression, PLATFORM.RUNLATER(()->{metodoDaEseguire();});
- Classe application contiene solo solo start()










